// <auto-generated>
/*
 * UAPI
 *
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using uapi-sdk-csharp.Client;
using uapi-sdk-csharp.Model;
using System.Diagnostics.CodeAnalysis;

namespace uapi-sdk-csharp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IWebParseApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        WebParseApiEvents Events { get; }

        /// <summary>
        /// 查询网页转换任务状态和结果
        /// </summary>
        /// <remarks>
        /// 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |- -- -- -|- -- -- -|- -- -- -|- -- -- -- -- -| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId">任务ID（由提交接口返回）</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebTomarkdownAsyncStatusApiResponse"/>&gt;</returns>
        Task<IGetWebTomarkdownAsyncStatusApiResponse> GetWebTomarkdownAsyncStatusAsync(string taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询网页转换任务状态和结果
        /// </summary>
        /// <remarks>
        /// 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |- -- -- -|- -- -- -|- -- -- -|- -- -- -- -- -| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
        /// </remarks>
        /// <param name="taskId">任务ID（由提交接口返回）</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebTomarkdownAsyncStatusApiResponse"/>?&gt;</returns>
        Task<IGetWebTomarkdownAsyncStatusApiResponse?> GetWebTomarkdownAsyncStatusOrDefaultAsync(string taskId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 提取网页中的所有图片
        /// </summary>
        /// <remarks>
        /// 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">需要提取图片的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseExtractimagesApiResponse"/>&gt;</returns>
        Task<IGetWebparseExtractimagesApiResponse> GetWebparseExtractimagesAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 提取网页中的所有图片
        /// </summary>
        /// <remarks>
        /// 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
        /// </remarks>
        /// <param name="url">需要提取图片的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseExtractimagesApiResponse"/>?&gt;</returns>
        Task<IGetWebparseExtractimagesApiResponse?> GetWebparseExtractimagesOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 抓取并解析网页的元数据
        /// </summary>
        /// <remarks>
        /// 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">需要提取元数据的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseMetadataApiResponse"/>&gt;</returns>
        Task<IGetWebparseMetadataApiResponse> GetWebparseMetadataAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 抓取并解析网页的元数据
        /// </summary>
        /// <remarks>
        /// 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
        /// </remarks>
        /// <param name="url">需要提取元数据的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseMetadataApiResponse"/>?&gt;</returns>
        Task<IGetWebparseMetadataApiResponse?> GetWebparseMetadataOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 深度抓取网页转Markdown
        /// </summary>
        /// <remarks>
        /// 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">需要转换的网页URL。URL必须经过编码。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebTomarkdownAsyncApiResponse"/>&gt;</returns>
        Task<IPostWebTomarkdownAsyncApiResponse> PostWebTomarkdownAsyncAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 深度抓取网页转Markdown
        /// </summary>
        /// <remarks>
        /// 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
        /// </remarks>
        /// <param name="url">需要转换的网页URL。URL必须经过编码。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebTomarkdownAsyncApiResponse"/>?&gt;</returns>
        Task<IPostWebTomarkdownAsyncApiResponse?> PostWebTomarkdownAsyncOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetWebTomarkdownAsyncStatusApiResponse"/>
    /// </summary>
    public interface IGetWebTomarkdownAsyncStatusApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus200Response?>, INotFound<uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus404Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetWebparseExtractimagesApiResponse"/>
    /// </summary>
    public interface IGetWebparseExtractimagesApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetWebparseExtractimages200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetImageTobase64400Response?>, IInternalServerError<uapi-sdk-csharp.Model.GetWebparseExtractimages500Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetWebparseMetadataApiResponse"/>
    /// </summary>
    public interface IGetWebparseMetadataApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetWebparseMetadata200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetImageTobase64400Response?>, IInternalServerError<uapi-sdk-csharp.Model.GetWebparseMetadata500Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPostWebTomarkdownAsyncApiResponse"/>
    /// </summary>
    public interface IPostWebTomarkdownAsyncApiResponse : uapi-sdk-csharp.Client.IApiResponse, IAccepted<uapi-sdk-csharp.Model.PostWebTomarkdownAsync202Response?>, IBadRequest<uapi-sdk-csharp.Model.PostWebTomarkdownAsync400Response?>
    {
        /// <summary>
        /// Returns true if the response is 202 Accepted
        /// </summary>
        /// <returns></returns>
        bool IsAccepted { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class WebParseApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebTomarkdownAsyncStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebTomarkdownAsyncStatus;

        internal void ExecuteOnGetWebTomarkdownAsyncStatus(WebParseApi.GetWebTomarkdownAsyncStatusApiResponse apiResponse)
        {
            OnGetWebTomarkdownAsyncStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebTomarkdownAsyncStatus(Exception exception)
        {
            OnErrorGetWebTomarkdownAsyncStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebparseExtractimages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebparseExtractimages;

        internal void ExecuteOnGetWebparseExtractimages(WebParseApi.GetWebparseExtractimagesApiResponse apiResponse)
        {
            OnGetWebparseExtractimages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebparseExtractimages(Exception exception)
        {
            OnErrorGetWebparseExtractimages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebparseMetadata;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebparseMetadata;

        internal void ExecuteOnGetWebparseMetadata(WebParseApi.GetWebparseMetadataApiResponse apiResponse)
        {
            OnGetWebparseMetadata?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebparseMetadata(Exception exception)
        {
            OnErrorGetWebparseMetadata?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostWebTomarkdownAsync;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostWebTomarkdownAsync;

        internal void ExecuteOnPostWebTomarkdownAsync(WebParseApi.PostWebTomarkdownAsyncApiResponse apiResponse)
        {
            OnPostWebTomarkdownAsync?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostWebTomarkdownAsync(Exception exception)
        {
            OnErrorPostWebTomarkdownAsync?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class WebParseApi : IWebParseApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<WebParseApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public WebParseApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="WebParseApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WebParseApi(ILogger<WebParseApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, WebParseApiEvents webParseApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<WebParseApi>();
            HttpClient = httpClient;
            Events = webParseApiEvents;
        }

        partial void FormatGetWebTomarkdownAsyncStatus(ref string taskId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="taskId"></param>
        /// <returns></returns>
        private void ValidateGetWebTomarkdownAsyncStatus(string taskId)
        {
            if (taskId == null)
                throw new ArgumentNullException(nameof(taskId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        private void AfterGetWebTomarkdownAsyncStatusDefaultImplementation(IGetWebTomarkdownAsyncStatusApiResponse apiResponseLocalVar, string taskId)
        {
            bool suppressDefaultLog = false;
            AfterGetWebTomarkdownAsyncStatus(ref suppressDefaultLog, apiResponseLocalVar, taskId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="taskId"></param>
        partial void AfterGetWebTomarkdownAsyncStatus(ref bool suppressDefaultLog, IGetWebTomarkdownAsyncStatusApiResponse apiResponseLocalVar, string taskId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        private void OnErrorGetWebTomarkdownAsyncStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string taskId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetWebTomarkdownAsyncStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, taskId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="taskId"></param>
        partial void OnErrorGetWebTomarkdownAsyncStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string taskId);

        /// <summary>
        /// 查询网页转换任务状态和结果 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |- -- -- -|- -- -- -|- -- -- -|- -- -- -- -- -| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
        /// </summary>
        /// <param name="taskId">任务ID（由提交接口返回）</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebTomarkdownAsyncStatusApiResponse"/>&gt;</returns>
        public async Task<IGetWebTomarkdownAsyncStatusApiResponse?> GetWebTomarkdownAsyncStatusOrDefaultAsync(string taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebTomarkdownAsyncStatusAsync(taskId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询网页转换任务状态和结果 提交了URL转Markdown任务后，想知道处理进度和结果？这个接口可以帮你实时追踪。  ## 功能概述  通过之前提交任务时获得的任务ID，你可以查询该任务的当前状态、处理进度以及最终结果。任务结果会在缓存中保存30分钟，期间可以重复查询，非常方便。  任务有五种状态：等待处理（pending）时进度为0%；处理中（processing）时进度在10-90%之间；已完成（completed）时进度为100%并返回Markdown内容；失败（failed）时会返回错误信息；超时（timeout）表示任务处理时间超过60秒已被取消。建议采用指数退避策略进行轮询，初始延迟1秒，每次延迟增加20%，最大延迟5秒。当状态为已完成、失败或超时时停止轮询。  系统会自动管理任务生命周期，单个任务最长处理时间为60秒，任务结果保存30分钟后自动清理，每5分钟清理一次过期任务。  ## 任务状态说明  | 状态 | 说明 | 进度 | 轮询建议 | |- -- -- -|- -- -- -|- -- -- -|- -- -- -- -- -| | &#x60;pending&#x60; | 等待处理 | 0% | 立即开始轮询 | | &#x60;processing&#x60; | 处理中 | 10-90% | 每2-5秒轮询一次 | | &#x60;completed&#x60; | 已完成 | 100% | 停止轮询，获取结果 | | &#x60;failed&#x60; | 失败 | 100% | 停止轮询，查看错误信息 | | &#x60;timeout&#x60; | 超时 | 100% | 停止轮询，任务已取消 |
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="taskId">任务ID（由提交接口返回）</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebTomarkdownAsyncStatusApiResponse"/>&gt;</returns>
        public async Task<IGetWebTomarkdownAsyncStatusApiResponse> GetWebTomarkdownAsyncStatusAsync(string taskId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetWebTomarkdownAsyncStatus(taskId);

                FormatGetWebTomarkdownAsyncStatus(ref taskId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/web/tomarkdown/async/{task_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/web/tomarkdown/async/{task_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btask_id%7D", Uri.EscapeDataString(taskId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetWebTomarkdownAsyncStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebTomarkdownAsyncStatusApiResponse>();
                        GetWebTomarkdownAsyncStatusApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/web/tomarkdown/async/{task_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetWebTomarkdownAsyncStatusDefaultImplementation(apiResponseLocalVar, taskId);

                        Events.ExecuteOnGetWebTomarkdownAsyncStatus(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebTomarkdownAsyncStatusDefaultImplementation(e, "/web/tomarkdown/async/{task_id}", uriBuilderLocalVar.Path, taskId);
                Events.ExecuteOnErrorGetWebTomarkdownAsyncStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebTomarkdownAsyncStatusApiResponse"/>
        /// </summary>
        public partial class GetWebTomarkdownAsyncStatusApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetWebTomarkdownAsyncStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebTomarkdownAsyncStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebTomarkdownAsyncStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebTomarkdownAsyncStatusApiResponse(ILogger<GetWebTomarkdownAsyncStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetWebTomarkdownAsyncStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebTomarkdownAsyncStatusApiResponse(ILogger<GetWebTomarkdownAsyncStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus404Response? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus404Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetWebTomarkdownAsyncStatus404Response? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetWebparseExtractimages(ref string url);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        private void ValidateGetWebparseExtractimages(string url)
        {
            if (url == null)
                throw new ArgumentNullException(nameof(url));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        private void AfterGetWebparseExtractimagesDefaultImplementation(IGetWebparseExtractimagesApiResponse apiResponseLocalVar, string url)
        {
            bool suppressDefaultLog = false;
            AfterGetWebparseExtractimages(ref suppressDefaultLog, apiResponseLocalVar, url);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        partial void AfterGetWebparseExtractimages(ref bool suppressDefaultLog, IGetWebparseExtractimagesApiResponse apiResponseLocalVar, string url);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        private void OnErrorGetWebparseExtractimagesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetWebparseExtractimages(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, url);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        partial void OnErrorGetWebparseExtractimages(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url);

        /// <summary>
        /// 提取网页中的所有图片 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
        /// </summary>
        /// <param name="url">需要提取图片的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseExtractimagesApiResponse"/>&gt;</returns>
        public async Task<IGetWebparseExtractimagesApiResponse?> GetWebparseExtractimagesOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebparseExtractimagesAsync(url, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 提取网页中的所有图片 想一次性“打包”一个网页上的所有图片吗？这个接口可以帮你实现。  ## 功能概述 你提供一个网页的URL，我们会访问该页面，解析其HTML内容，并提取出所有 &#x60;&lt;img&gt;&#x60; 标签中的图片链接，然后将这些链接列表返回给你。非常适合用于制作图片采集器或素材下载工具。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">需要提取图片的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseExtractimagesApiResponse"/>&gt;</returns>
        public async Task<IGetWebparseExtractimagesApiResponse> GetWebparseExtractimagesAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetWebparseExtractimages(url);

                FormatGetWebparseExtractimages(ref url);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/webparse/extractimages"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/webparse/extractimages");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetWebparseExtractimagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebparseExtractimagesApiResponse>();
                        GetWebparseExtractimagesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webparse/extractimages", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetWebparseExtractimagesDefaultImplementation(apiResponseLocalVar, url);

                        Events.ExecuteOnGetWebparseExtractimages(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebparseExtractimagesDefaultImplementation(e, "/webparse/extractimages", uriBuilderLocalVar.Path, url);
                Events.ExecuteOnErrorGetWebparseExtractimages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebparseExtractimagesApiResponse"/>
        /// </summary>
        public partial class GetWebparseExtractimagesApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetWebparseExtractimagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebparseExtractimagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebparseExtractimagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebparseExtractimagesApiResponse(ILogger<GetWebparseExtractimagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetWebparseExtractimagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebparseExtractimagesApiResponse(ILogger<GetWebparseExtractimagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetWebparseExtractimages200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetWebparseExtractimages200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetWebparseExtractimages200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetImageTobase64400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetImageTobase64400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetImageTobase64400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetWebparseExtractimages500Response? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetWebparseExtractimages500Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetWebparseExtractimages500Response? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetWebparseMetadata(ref string url);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        private void ValidateGetWebparseMetadata(string url)
        {
            if (url == null)
                throw new ArgumentNullException(nameof(url));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        private void AfterGetWebparseMetadataDefaultImplementation(IGetWebparseMetadataApiResponse apiResponseLocalVar, string url)
        {
            bool suppressDefaultLog = false;
            AfterGetWebparseMetadata(ref suppressDefaultLog, apiResponseLocalVar, url);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        partial void AfterGetWebparseMetadata(ref bool suppressDefaultLog, IGetWebparseMetadataApiResponse apiResponseLocalVar, string url);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        private void OnErrorGetWebparseMetadataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetWebparseMetadata(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, url);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        partial void OnErrorGetWebparseMetadata(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url);

        /// <summary>
        /// 抓取并解析网页的元数据 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
        /// </summary>
        /// <param name="url">需要提取元数据的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseMetadataApiResponse"/>&gt;</returns>
        public async Task<IGetWebparseMetadataApiResponse?> GetWebparseMetadataOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebparseMetadataAsync(url, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 抓取并解析网页的元数据 当你在应用中需要展示一个链接的预览时（就像微信或Telegram里那样），这个接口能帮你轻松获取所需信息。  ## 功能概述 你提供一个网页的URL，我们会抓取并解析它的 &#x60;&lt;head&gt;&#x60; 部分，提取出关键的元数据（Metadata），如页面标题（Title）、描述（Description）、关键词（Keywords）以及网站图标（Favicon）等。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">需要提取元数据的网页URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebparseMetadataApiResponse"/>&gt;</returns>
        public async Task<IGetWebparseMetadataApiResponse> GetWebparseMetadataAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetWebparseMetadata(url);

                FormatGetWebparseMetadata(ref url);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/webparse/metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/webparse/metadata");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetWebparseMetadataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebparseMetadataApiResponse>();
                        GetWebparseMetadataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webparse/metadata", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetWebparseMetadataDefaultImplementation(apiResponseLocalVar, url);

                        Events.ExecuteOnGetWebparseMetadata(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebparseMetadataDefaultImplementation(e, "/webparse/metadata", uriBuilderLocalVar.Path, url);
                Events.ExecuteOnErrorGetWebparseMetadata(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebparseMetadataApiResponse"/>
        /// </summary>
        public partial class GetWebparseMetadataApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetWebparseMetadataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebparseMetadataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebparseMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebparseMetadataApiResponse(ILogger<GetWebparseMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetWebparseMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebparseMetadataApiResponse(ILogger<GetWebparseMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetWebparseMetadata200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetWebparseMetadata200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetWebparseMetadata200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetImageTobase64400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetImageTobase64400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetImageTobase64400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetWebparseMetadata500Response? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetWebparseMetadata500Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetWebparseMetadata500Response? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostWebTomarkdownAsync(ref string url);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        private void ValidatePostWebTomarkdownAsync(string url)
        {
            if (url == null)
                throw new ArgumentNullException(nameof(url));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        private void AfterPostWebTomarkdownAsyncDefaultImplementation(IPostWebTomarkdownAsyncApiResponse apiResponseLocalVar, string url)
        {
            bool suppressDefaultLog = false;
            AfterPostWebTomarkdownAsync(ref suppressDefaultLog, apiResponseLocalVar, url);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        partial void AfterPostWebTomarkdownAsync(ref bool suppressDefaultLog, IPostWebTomarkdownAsyncApiResponse apiResponseLocalVar, string url);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        private void OnErrorPostWebTomarkdownAsyncDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostWebTomarkdownAsync(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, url);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        partial void OnErrorPostWebTomarkdownAsync(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url);

        /// <summary>
        /// 深度抓取网页转Markdown 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
        /// </summary>
        /// <param name="url">需要转换的网页URL。URL必须经过编码。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebTomarkdownAsyncApiResponse"/>&gt;</returns>
        public async Task<IPostWebTomarkdownAsyncApiResponse?> PostWebTomarkdownAsyncOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostWebTomarkdownAsyncAsync(url, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 深度抓取网页转Markdown 想要将复杂的网页转换为结构清晰的Markdown？这个接口采用异步处理模式，特别适合处理大型网页、复杂网站或需要长时间处理的转换任务。  ## 功能概述  &gt; [!VIP] &gt;本API目前处于**限时免费**阶段，我们鼓励开发者集成和测试。未来，它将转为付费API，为用户提供更稳定和强大的服务。  UAPI Pro平台推出的异步网页转Markdown API能够将任意网页URL转换为结构清晰、格式优美的Markdown文本。提交任务后立即返回任务ID，不会阻塞客户端等待。您可以通过任务ID实时查询转换进度和处理状态，支持长达60秒的处理时间，轻松应对大型网站、需要JS渲染的单页应用等复杂页面。任务结果会缓存30分钟，期间可重复查询，过期任务自动清理无需手动管理。  此API采用先进算法，自动识别并抓取网页主体内容，精准剔除广告、导航栏、页眉页脚等无关元素。完美保留原文的格式，包括标题、列表、代码块、表格、引用、图片等，并输出为兼容性强的GitHub Flavored Markdown (GFM) 格式。同时会自动解析并提取文章标题、作者、发布日期、站点名称等关键元数据，并将其格式化为标准的YAML Front Matter，方便后续处理和CMS集成。  ## 使用流程  调用本接口提交URL转换任务后，会立即获得一个唯一的任务ID。随后使用任务ID调用查询接口，获取任务状态和进度。任务完成后，从查询接口的响应中获取Markdown内容。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">需要转换的网页URL。URL必须经过编码。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebTomarkdownAsyncApiResponse"/>&gt;</returns>
        public async Task<IPostWebTomarkdownAsyncApiResponse> PostWebTomarkdownAsyncAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostWebTomarkdownAsync(url);

                FormatPostWebTomarkdownAsync(ref url);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/web/tomarkdown/async"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/web/tomarkdown/async");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PostWebTomarkdownAsyncApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostWebTomarkdownAsyncApiResponse>();
                        PostWebTomarkdownAsyncApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/web/tomarkdown/async", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPostWebTomarkdownAsyncDefaultImplementation(apiResponseLocalVar, url);

                        Events.ExecuteOnPostWebTomarkdownAsync(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostWebTomarkdownAsyncDefaultImplementation(e, "/web/tomarkdown/async", uriBuilderLocalVar.Path, url);
                Events.ExecuteOnErrorPostWebTomarkdownAsync(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostWebTomarkdownAsyncApiResponse"/>
        /// </summary>
        public partial class PostWebTomarkdownAsyncApiResponse : uapi-sdk-csharp.Client.ApiResponse, IPostWebTomarkdownAsyncApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostWebTomarkdownAsyncApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostWebTomarkdownAsyncApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostWebTomarkdownAsyncApiResponse(ILogger<PostWebTomarkdownAsyncApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PostWebTomarkdownAsyncApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostWebTomarkdownAsyncApiResponse(ILogger<PostWebTomarkdownAsyncApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public bool IsAccepted => 202 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 202 Accepted
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.PostWebTomarkdownAsync202Response? Accepted()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsAccepted
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.PostWebTomarkdownAsync202Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 202 Accepted and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryAccepted([NotNullWhen(true)]out uapi-sdk-csharp.Model.PostWebTomarkdownAsync202Response? result)
            {
                result = null;

                try
                {
                    result = Accepted();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)202);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.PostWebTomarkdownAsync400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.PostWebTomarkdownAsync400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.PostWebTomarkdownAsync400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
