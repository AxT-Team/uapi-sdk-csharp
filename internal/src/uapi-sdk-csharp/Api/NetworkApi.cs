// <auto-generated>
/*
 * UAPI
 *
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using uapi-sdk-csharp.Client;
using uapi-sdk-csharp.Model;
using System.Diagnostics.CodeAnalysis;

namespace uapi-sdk-csharp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface INetworkApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        NetworkApiEvents Events { get; }

        /// <summary>
        /// 执行DNS解析查询
        /// </summary>
        /// <remarks>
        /// 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">你需要查询的域名，例如 &#39;cn.bing.com&#39;。</param>
        /// <param name="type">你想要查询的DNS记录类型。 (optional, default to A)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkDnsApiResponse"/>&gt;</returns>
        Task<IGetNetworkDnsApiResponse> GetNetworkDnsAsync(string domain, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 执行DNS解析查询
        /// </summary>
        /// <remarks>
        /// 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
        /// </remarks>
        /// <param name="domain">你需要查询的域名，例如 &#39;cn.bing.com&#39;。</param>
        /// <param name="type">你想要查询的DNS记录类型。 (optional, default to A)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkDnsApiResponse"/>?&gt;</returns>
        Task<IGetNetworkDnsApiResponse?> GetNetworkDnsOrDefaultAsync(string domain, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询域名ICP备案信息
        /// </summary>
        /// <remarks>
        /// 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">需要查询的域名或URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIcpApiResponse"/>&gt;</returns>
        Task<IGetNetworkIcpApiResponse> GetNetworkIcpAsync(string domain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询域名ICP备案信息
        /// </summary>
        /// <remarks>
        /// 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
        /// </remarks>
        /// <param name="domain">需要查询的域名或URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIcpApiResponse"/>?&gt;</returns>
        Task<IGetNetworkIcpApiResponse?> GetNetworkIcpOrDefaultAsync(string domain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定IP或域名的归属信息
        /// </summary>
        /// <remarks>
        /// 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ip">你需要查询的公网IP地址或域名（支持IPv4和IPv6）。</param>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIpinfoApiResponse"/>&gt;</returns>
        Task<IGetNetworkIpinfoApiResponse> GetNetworkIpinfoAsync(string ip, Option<string> source = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询指定IP或域名的归属信息
        /// </summary>
        /// <remarks>
        /// 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </remarks>
        /// <param name="ip">你需要查询的公网IP地址或域名（支持IPv4和IPv6）。</param>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIpinfoApiResponse"/>?&gt;</returns>
        Task<IGetNetworkIpinfoApiResponse?> GetNetworkIpinfoOrDefaultAsync(string ip, Option<string> source = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 获取你的公网IP及归属信息
        /// </summary>
        /// <remarks>
        /// 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkMyipApiResponse"/>&gt;</returns>
        Task<IGetNetworkMyipApiResponse> GetNetworkMyipAsync(Option<string> source = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 获取你的公网IP及归属信息
        /// </summary>
        /// <remarks>
        /// 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </remarks>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkMyipApiResponse"/>?&gt;</returns>
        Task<IGetNetworkMyipApiResponse?> GetNetworkMyipOrDefaultAsync(Option<string> source = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 从服务器Ping指定主机
        /// </summary>
        /// <remarks>
        /// 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="host">你需要 Ping 的目标主机，可以是域名或IP地址。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingApiResponse"/>&gt;</returns>
        Task<IGetNetworkPingApiResponse> GetNetworkPingAsync(string host, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 从服务器Ping指定主机
        /// </summary>
        /// <remarks>
        /// 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
        /// </remarks>
        /// <param name="host">你需要 Ping 的目标主机，可以是域名或IP地址。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingApiResponse"/>?&gt;</returns>
        Task<IGetNetworkPingApiResponse?> GetNetworkPingOrDefaultAsync(string host, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 从服务器Ping你的客户端IP
        /// </summary>
        /// <remarks>
        /// 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingmyipApiResponse"/>&gt;</returns>
        Task<IGetNetworkPingmyipApiResponse> GetNetworkPingmyipAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 从服务器Ping你的客户端IP
        /// </summary>
        /// <remarks>
        /// 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingmyipApiResponse"/>?&gt;</returns>
        Task<IGetNetworkPingmyipApiResponse?> GetNetworkPingmyipOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 扫描远程主机的指定端口
        /// </summary>
        /// <remarks>
        /// 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="host">需要扫描的目标主机，可以是域名或IP地址。</param>
        /// <param name="port">需要扫描的端口号，范围是 1 到 65535。</param>
        /// <param name="protocol">扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPortscanApiResponse"/>&gt;</returns>
        Task<IGetNetworkPortscanApiResponse> GetNetworkPortscanAsync(string host, int port, Option<string> protocol = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 扫描远程主机的指定端口
        /// </summary>
        /// <remarks>
        /// 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
        /// </remarks>
        /// <param name="host">需要扫描的目标主机，可以是域名或IP地址。</param>
        /// <param name="port">需要扫描的端口号，范围是 1 到 65535。</param>
        /// <param name="protocol">扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPortscanApiResponse"/>?&gt;</returns>
        Task<IGetNetworkPortscanApiResponse?> GetNetworkPortscanOrDefaultAsync(string host, int port, Option<string> protocol = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 检查URL的可访问性状态
        /// </summary>
        /// <remarks>
        /// 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">你需要检查其可访问性状态的完整URL。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkUrlstatusApiResponse"/>&gt;</returns>
        Task<IGetNetworkUrlstatusApiResponse> GetNetworkUrlstatusAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 检查URL的可访问性状态
        /// </summary>
        /// <remarks>
        /// 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
        /// </remarks>
        /// <param name="url">你需要检查其可访问性状态的完整URL。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkUrlstatusApiResponse"/>?&gt;</returns>
        Task<IGetNetworkUrlstatusApiResponse?> GetNetworkUrlstatusOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询域名的WHOIS注册信息
        /// </summary>
        /// <remarks>
        /// 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">你需要查询WHOIS信息的域名。</param>
        /// <param name="format">返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWhoisApiResponse"/>&gt;</returns>
        Task<IGetNetworkWhoisApiResponse> GetNetworkWhoisAsync(string domain, Option<string> format = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 查询域名的WHOIS注册信息
        /// </summary>
        /// <remarks>
        /// 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
        /// </remarks>
        /// <param name="domain">你需要查询WHOIS信息的域名。</param>
        /// <param name="format">返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWhoisApiResponse"/>?&gt;</returns>
        Task<IGetNetworkWhoisApiResponse?> GetNetworkWhoisOrDefaultAsync(string domain, Option<string> format = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 检查域名在微信中的访问状态
        /// </summary>
        /// <remarks>
        /// 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">需要查询的域名。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWxdomainApiResponse"/>&gt;</returns>
        Task<IGetNetworkWxdomainApiResponse> GetNetworkWxdomainAsync(string domain, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 检查域名在微信中的访问状态
        /// </summary>
        /// <remarks>
        /// 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
        /// </remarks>
        /// <param name="domain">需要查询的域名。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWxdomainApiResponse"/>?&gt;</returns>
        Task<IGetNetworkWxdomainApiResponse?> GetNetworkWxdomainOrDefaultAsync(string domain, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetNetworkDnsApiResponse"/>
    /// </summary>
    public interface IGetNetworkDnsApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkDns200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkDns400Response?>, INotFound<uapi-sdk-csharp.Model.GetNetworkDns404Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkIcpApiResponse"/>
    /// </summary>
    public interface IGetNetworkIcpApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkIcp200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkDns400Response?>, INotFound<uapi-sdk-csharp.Model.GetNetworkIcp404Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkIpinfoApiResponse"/>
    /// </summary>
    public interface IGetNetworkIpinfoApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkIpinfo200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkIpinfo400Response?>, INotFound<uapi-sdk-csharp.Model.GetNetworkIpinfo404Response?>, IInternalServerError<uapi-sdk-csharp.Model.GetNetworkIpinfo500Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkMyipApiResponse"/>
    /// </summary>
    public interface IGetNetworkMyipApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkIpinfo200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkMyip400Response?>, IInternalServerError<uapi-sdk-csharp.Model.GetNetworkMyip500Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkPingApiResponse"/>
    /// </summary>
    public interface IGetNetworkPingApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkPing200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkPing400Response?>, ITooManyRequests<uapi-sdk-csharp.Model.GetNetworkPing429Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkPingmyipApiResponse"/>
    /// </summary>
    public interface IGetNetworkPingmyipApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkPingmyip200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkMyip400Response?>, INotFound<uapi-sdk-csharp.Model.GetNetworkPingmyip404Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkPortscanApiResponse"/>
    /// </summary>
    public interface IGetNetworkPortscanApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkPortscan200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkPortscan400Response?>, IInternalServerError<uapi-sdk-csharp.Model.GetNetworkPortscan500Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkUrlstatusApiResponse"/>
    /// </summary>
    public interface IGetNetworkUrlstatusApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkUrlstatus200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetImageTobase64400Response?>, IBadGateway<uapi-sdk-csharp.Model.GetNetworkUrlstatus502Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 502 BadGateway
        /// </summary>
        /// <returns></returns>
        bool IsBadGateway { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkWhoisApiResponse"/>
    /// </summary>
    public interface IGetNetworkWhoisApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkWhois200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkDns400Response?>, INotFound<uapi-sdk-csharp.Model.GetNetworkWhois404Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkWxdomainApiResponse"/>
    /// </summary>
    public interface IGetNetworkWxdomainApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetNetworkWxdomain200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetNetworkDns400Response?>, IBadGateway<uapi-sdk-csharp.Model.GetNetworkWxdomain502Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 502 BadGateway
        /// </summary>
        /// <returns></returns>
        bool IsBadGateway { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class NetworkApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkDns;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkDns;

        internal void ExecuteOnGetNetworkDns(NetworkApi.GetNetworkDnsApiResponse apiResponse)
        {
            OnGetNetworkDns?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkDns(Exception exception)
        {
            OnErrorGetNetworkDns?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkIcp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkIcp;

        internal void ExecuteOnGetNetworkIcp(NetworkApi.GetNetworkIcpApiResponse apiResponse)
        {
            OnGetNetworkIcp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkIcp(Exception exception)
        {
            OnErrorGetNetworkIcp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkIpinfo;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkIpinfo;

        internal void ExecuteOnGetNetworkIpinfo(NetworkApi.GetNetworkIpinfoApiResponse apiResponse)
        {
            OnGetNetworkIpinfo?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkIpinfo(Exception exception)
        {
            OnErrorGetNetworkIpinfo?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkMyip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkMyip;

        internal void ExecuteOnGetNetworkMyip(NetworkApi.GetNetworkMyipApiResponse apiResponse)
        {
            OnGetNetworkMyip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkMyip(Exception exception)
        {
            OnErrorGetNetworkMyip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkPing;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkPing;

        internal void ExecuteOnGetNetworkPing(NetworkApi.GetNetworkPingApiResponse apiResponse)
        {
            OnGetNetworkPing?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkPing(Exception exception)
        {
            OnErrorGetNetworkPing?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkPingmyip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkPingmyip;

        internal void ExecuteOnGetNetworkPingmyip(NetworkApi.GetNetworkPingmyipApiResponse apiResponse)
        {
            OnGetNetworkPingmyip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkPingmyip(Exception exception)
        {
            OnErrorGetNetworkPingmyip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkPortscan;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkPortscan;

        internal void ExecuteOnGetNetworkPortscan(NetworkApi.GetNetworkPortscanApiResponse apiResponse)
        {
            OnGetNetworkPortscan?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkPortscan(Exception exception)
        {
            OnErrorGetNetworkPortscan?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkUrlstatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkUrlstatus;

        internal void ExecuteOnGetNetworkUrlstatus(NetworkApi.GetNetworkUrlstatusApiResponse apiResponse)
        {
            OnGetNetworkUrlstatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkUrlstatus(Exception exception)
        {
            OnErrorGetNetworkUrlstatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkWhois;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkWhois;

        internal void ExecuteOnGetNetworkWhois(NetworkApi.GetNetworkWhoisApiResponse apiResponse)
        {
            OnGetNetworkWhois?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkWhois(Exception exception)
        {
            OnErrorGetNetworkWhois?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNetworkWxdomain;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNetworkWxdomain;

        internal void ExecuteOnGetNetworkWxdomain(NetworkApi.GetNetworkWxdomainApiResponse apiResponse)
        {
            OnGetNetworkWxdomain?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkWxdomain(Exception exception)
        {
            OnErrorGetNetworkWxdomain?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class NetworkApi : INetworkApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<NetworkApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public NetworkApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="NetworkApi"/> class.
        /// </summary>
        /// <returns></returns>
        public NetworkApi(ILogger<NetworkApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, NetworkApiEvents networkApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<NetworkApi>();
            HttpClient = httpClient;
            Events = networkApiEvents;
        }

        partial void FormatGetNetworkDns(ref string domain, ref Option<string> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="domain"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        private void ValidateGetNetworkDns(string domain, Option<string> type)
        {
            if (domain == null)
                throw new ArgumentNullException(nameof(domain));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="type"></param>
        private void AfterGetNetworkDnsDefaultImplementation(IGetNetworkDnsApiResponse apiResponseLocalVar, string domain, Option<string> type)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkDns(ref suppressDefaultLog, apiResponseLocalVar, domain, type);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="type"></param>
        partial void AfterGetNetworkDns(ref bool suppressDefaultLog, IGetNetworkDnsApiResponse apiResponseLocalVar, string domain, Option<string> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="type"></param>
        private void OnErrorGetNetworkDnsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain, Option<string> type)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkDns(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, domain, type);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="type"></param>
        partial void OnErrorGetNetworkDns(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain, Option<string> type);

        /// <summary>
        /// 执行DNS解析查询 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
        /// </summary>
        /// <param name="domain">你需要查询的域名，例如 &#39;cn.bing.com&#39;。</param>
        /// <param name="type">你想要查询的DNS记录类型。 (optional, default to A)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkDnsApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkDnsApiResponse?> GetNetworkDnsOrDefaultAsync(string domain, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkDnsAsync(domain, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 执行DNS解析查询 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 &#x60;dig&#x60; 或 &#x60;nslookup&#x60; 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 &#x60;A&#x60; (IPv4), &#x60;AAAA&#x60; (IPv6), &#x60;CNAME&#x60; (别名), &#x60;MX&#x60; (邮件交换), &#x60;NS&#x60; (域名服务器) 和 &#x60;TXT&#x60; (文本记录)。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">你需要查询的域名，例如 &#39;cn.bing.com&#39;。</param>
        /// <param name="type">你想要查询的DNS记录类型。 (optional, default to A)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkDnsApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkDnsApiResponse> GetNetworkDnsAsync(string domain, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkDns(domain, type);

                FormatGetNetworkDns(ref domain, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/dns"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/dns");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["domain"] = ClientUtils.ParameterToString(domain);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkDnsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkDnsApiResponse>();
                        GetNetworkDnsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/dns", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkDnsDefaultImplementation(apiResponseLocalVar, domain, type);

                        Events.ExecuteOnGetNetworkDns(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkDnsDefaultImplementation(e, "/network/dns", uriBuilderLocalVar.Path, domain, type);
                Events.ExecuteOnErrorGetNetworkDns(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkDnsApiResponse"/>
        /// </summary>
        public partial class GetNetworkDnsApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkDnsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkDnsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkDnsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkDnsApiResponse(ILogger<GetNetworkDnsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkDnsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkDnsApiResponse(ILogger<GetNetworkDnsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkDns200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkDns200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkDns200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkDns400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkDns400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkDns400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkDns404Response? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkDns404Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkDns404Response? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkIcp(ref string domain);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="domain"></param>
        /// <returns></returns>
        private void ValidateGetNetworkIcp(string domain)
        {
            if (domain == null)
                throw new ArgumentNullException(nameof(domain));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        private void AfterGetNetworkIcpDefaultImplementation(IGetNetworkIcpApiResponse apiResponseLocalVar, string domain)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkIcp(ref suppressDefaultLog, apiResponseLocalVar, domain);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        partial void AfterGetNetworkIcp(ref bool suppressDefaultLog, IGetNetworkIcpApiResponse apiResponseLocalVar, string domain);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        private void OnErrorGetNetworkIcpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkIcp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, domain);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        partial void OnErrorGetNetworkIcp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain);

        /// <summary>
        /// 查询域名ICP备案信息 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
        /// </summary>
        /// <param name="domain">需要查询的域名或URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIcpApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkIcpApiResponse?> GetNetworkIcpOrDefaultAsync(string domain, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkIcpAsync(domain, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询域名ICP备案信息 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  &gt; [!NOTE] &gt; **查询范围** &gt; 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">需要查询的域名或URL</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIcpApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkIcpApiResponse> GetNetworkIcpAsync(string domain, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkIcp(domain);

                FormatGetNetworkIcp(ref domain);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/icp"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/icp");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["domain"] = ClientUtils.ParameterToString(domain);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkIcpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkIcpApiResponse>();
                        GetNetworkIcpApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/icp", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkIcpDefaultImplementation(apiResponseLocalVar, domain);

                        Events.ExecuteOnGetNetworkIcp(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkIcpDefaultImplementation(e, "/network/icp", uriBuilderLocalVar.Path, domain);
                Events.ExecuteOnErrorGetNetworkIcp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkIcpApiResponse"/>
        /// </summary>
        public partial class GetNetworkIcpApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkIcpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkIcpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkIcpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkIcpApiResponse(ILogger<GetNetworkIcpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkIcpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkIcpApiResponse(ILogger<GetNetworkIcpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIcp200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIcp200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIcp200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkDns400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkDns400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkDns400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIcp404Response? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIcp404Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIcp404Response? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkIpinfo(ref string ip, ref Option<string> source);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ip"></param>
        /// <param name="source"></param>
        /// <returns></returns>
        private void ValidateGetNetworkIpinfo(string ip, Option<string> source)
        {
            if (ip == null)
                throw new ArgumentNullException(nameof(ip));

            if (source.IsSet && source.Value == null)
                throw new ArgumentNullException(nameof(source));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ip"></param>
        /// <param name="source"></param>
        private void AfterGetNetworkIpinfoDefaultImplementation(IGetNetworkIpinfoApiResponse apiResponseLocalVar, string ip, Option<string> source)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkIpinfo(ref suppressDefaultLog, apiResponseLocalVar, ip, source);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ip"></param>
        /// <param name="source"></param>
        partial void AfterGetNetworkIpinfo(ref bool suppressDefaultLog, IGetNetworkIpinfoApiResponse apiResponseLocalVar, string ip, Option<string> source);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ip"></param>
        /// <param name="source"></param>
        private void OnErrorGetNetworkIpinfoDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string ip, Option<string> source)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkIpinfo(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ip, source);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ip"></param>
        /// <param name="source"></param>
        partial void OnErrorGetNetworkIpinfo(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string ip, Option<string> source);

        /// <summary>
        /// 查询指定IP或域名的归属信息 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </summary>
        /// <param name="ip">你需要查询的公网IP地址或域名（支持IPv4和IPv6）。</param>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIpinfoApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkIpinfoApiResponse?> GetNetworkIpinfoOrDefaultAsync(string ip, Option<string> source = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkIpinfoAsync(ip, source, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询指定IP或域名的归属信息 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ip">你需要查询的公网IP地址或域名（支持IPv4和IPv6）。</param>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkIpinfoApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkIpinfoApiResponse> GetNetworkIpinfoAsync(string ip, Option<string> source = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkIpinfo(ip, source);

                FormatGetNetworkIpinfo(ref ip, ref source);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/ipinfo"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/ipinfo");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["ip"] = ClientUtils.ParameterToString(ip);

                    if (source.IsSet)
                        parseQueryStringLocalVar["source"] = ClientUtils.ParameterToString(source.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkIpinfoApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkIpinfoApiResponse>();
                        GetNetworkIpinfoApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/ipinfo", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkIpinfoDefaultImplementation(apiResponseLocalVar, ip, source);

                        Events.ExecuteOnGetNetworkIpinfo(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkIpinfoDefaultImplementation(e, "/network/ipinfo", uriBuilderLocalVar.Path, ip, source);
                Events.ExecuteOnErrorGetNetworkIpinfo(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkIpinfoApiResponse"/>
        /// </summary>
        public partial class GetNetworkIpinfoApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkIpinfoApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkIpinfoApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkIpinfoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkIpinfoApiResponse(ILogger<GetNetworkIpinfoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkIpinfoApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkIpinfoApiResponse(ILogger<GetNetworkIpinfoApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIpinfo200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIpinfo200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIpinfo200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIpinfo400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIpinfo400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIpinfo400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIpinfo404Response? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIpinfo404Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIpinfo404Response? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIpinfo500Response? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIpinfo500Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIpinfo500Response? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkMyip(ref Option<string> source);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        private void ValidateGetNetworkMyip(Option<string> source)
        {
            if (source.IsSet && source.Value == null)
                throw new ArgumentNullException(nameof(source));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="source"></param>
        private void AfterGetNetworkMyipDefaultImplementation(IGetNetworkMyipApiResponse apiResponseLocalVar, Option<string> source)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkMyip(ref suppressDefaultLog, apiResponseLocalVar, source);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="source"></param>
        partial void AfterGetNetworkMyip(ref bool suppressDefaultLog, IGetNetworkMyipApiResponse apiResponseLocalVar, Option<string> source);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="source"></param>
        private void OnErrorGetNetworkMyipDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> source)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkMyip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, source);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="source"></param>
        partial void OnErrorGetNetworkMyip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> source);

        /// <summary>
        /// 获取你的公网IP及归属信息 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </summary>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkMyipApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkMyipApiResponse?> GetNetworkMyipOrDefaultAsync(Option<string> source = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkMyipAsync(source, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 获取你的公网IP及归属信息 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 &#x60;source&#x3D;commercial&#x60; 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 &#x60;/network/ipinfo&#x60; 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 &#x60;source&#x3D;commercial&#x60; 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">查询的数据源。如果留空，将使用默认的数据库。如果设置为 &#x60;commercial&#x60;，将调用商业级API，返回更详细的地理位置信息，但响应时间可能会稍长。 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkMyipApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkMyipApiResponse> GetNetworkMyipAsync(Option<string> source = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkMyip(source);

                FormatGetNetworkMyip(ref source);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/myip"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/myip");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (source.IsSet)
                        parseQueryStringLocalVar["source"] = ClientUtils.ParameterToString(source.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkMyipApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkMyipApiResponse>();
                        GetNetworkMyipApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/myip", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkMyipDefaultImplementation(apiResponseLocalVar, source);

                        Events.ExecuteOnGetNetworkMyip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkMyipDefaultImplementation(e, "/network/myip", uriBuilderLocalVar.Path, source);
                Events.ExecuteOnErrorGetNetworkMyip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkMyipApiResponse"/>
        /// </summary>
        public partial class GetNetworkMyipApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkMyipApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkMyipApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkMyipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkMyipApiResponse(ILogger<GetNetworkMyipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkMyipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkMyipApiResponse(ILogger<GetNetworkMyipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkIpinfo200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkIpinfo200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkIpinfo200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkMyip400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkMyip400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkMyip400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkMyip500Response? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkMyip500Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkMyip500Response? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkPing(ref string host);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="host"></param>
        /// <returns></returns>
        private void ValidateGetNetworkPing(string host)
        {
            if (host == null)
                throw new ArgumentNullException(nameof(host));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="host"></param>
        private void AfterGetNetworkPingDefaultImplementation(IGetNetworkPingApiResponse apiResponseLocalVar, string host)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkPing(ref suppressDefaultLog, apiResponseLocalVar, host);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="host"></param>
        partial void AfterGetNetworkPing(ref bool suppressDefaultLog, IGetNetworkPingApiResponse apiResponseLocalVar, string host);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="host"></param>
        private void OnErrorGetNetworkPingDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string host)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkPing(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, host);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="host"></param>
        partial void OnErrorGetNetworkPing(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string host);

        /// <summary>
        /// 从服务器Ping指定主机 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
        /// </summary>
        /// <param name="host">你需要 Ping 的目标主机，可以是域名或IP地址。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkPingApiResponse?> GetNetworkPingOrDefaultAsync(string host, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkPingAsync(host, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 从服务器Ping指定主机 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="host">你需要 Ping 的目标主机，可以是域名或IP地址。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkPingApiResponse> GetNetworkPingAsync(string host, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkPing(host);

                FormatGetNetworkPing(ref host);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/ping"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/ping");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["host"] = ClientUtils.ParameterToString(host);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkPingApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkPingApiResponse>();
                        GetNetworkPingApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/ping", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkPingDefaultImplementation(apiResponseLocalVar, host);

                        Events.ExecuteOnGetNetworkPing(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkPingDefaultImplementation(e, "/network/ping", uriBuilderLocalVar.Path, host);
                Events.ExecuteOnErrorGetNetworkPing(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkPingApiResponse"/>
        /// </summary>
        public partial class GetNetworkPingApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkPingApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkPingApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkPingApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkPingApiResponse(ILogger<GetNetworkPingApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkPingApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkPingApiResponse(ILogger<GetNetworkPingApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPing200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPing200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPing200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPing400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPing400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPing400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPing429Response? TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPing429Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPing429Response? result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetNetworkPingmyipDefaultImplementation(IGetNetworkPingmyipApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkPingmyip(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetNetworkPingmyip(ref bool suppressDefaultLog, IGetNetworkPingmyipApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetNetworkPingmyipDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkPingmyip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetNetworkPingmyip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// 从服务器Ping你的客户端IP 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingmyipApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkPingmyipApiResponse?> GetNetworkPingmyipOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkPingmyipAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 从服务器Ping你的客户端IP 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 &#x60;/network/myip&#x60; 和 &#x60;/network/ping&#x60; 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPingmyipApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkPingmyipApiResponse> GetNetworkPingmyipAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/pingmyip"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/pingmyip");

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkPingmyipApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkPingmyipApiResponse>();
                        GetNetworkPingmyipApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/pingmyip", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkPingmyipDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetNetworkPingmyip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkPingmyipDefaultImplementation(e, "/network/pingmyip", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetNetworkPingmyip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkPingmyipApiResponse"/>
        /// </summary>
        public partial class GetNetworkPingmyipApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkPingmyipApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkPingmyipApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkPingmyipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkPingmyipApiResponse(ILogger<GetNetworkPingmyipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkPingmyipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkPingmyipApiResponse(ILogger<GetNetworkPingmyipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPingmyip200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPingmyip200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPingmyip200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkMyip400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkMyip400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkMyip400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPingmyip404Response? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPingmyip404Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPingmyip404Response? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkPortscan(ref string host, ref int port, ref Option<string> protocol);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="host"></param>
        /// <param name="protocol"></param>
        /// <returns></returns>
        private void ValidateGetNetworkPortscan(string host, Option<string> protocol)
        {
            if (host == null)
                throw new ArgumentNullException(nameof(host));

            if (protocol.IsSet && protocol.Value == null)
                throw new ArgumentNullException(nameof(protocol));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="host"></param>
        /// <param name="port"></param>
        /// <param name="protocol"></param>
        private void AfterGetNetworkPortscanDefaultImplementation(IGetNetworkPortscanApiResponse apiResponseLocalVar, string host, int port, Option<string> protocol)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkPortscan(ref suppressDefaultLog, apiResponseLocalVar, host, port, protocol);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="host"></param>
        /// <param name="port"></param>
        /// <param name="protocol"></param>
        partial void AfterGetNetworkPortscan(ref bool suppressDefaultLog, IGetNetworkPortscanApiResponse apiResponseLocalVar, string host, int port, Option<string> protocol);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="host"></param>
        /// <param name="port"></param>
        /// <param name="protocol"></param>
        private void OnErrorGetNetworkPortscanDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string host, int port, Option<string> protocol)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkPortscan(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, host, port, protocol);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="host"></param>
        /// <param name="port"></param>
        /// <param name="protocol"></param>
        partial void OnErrorGetNetworkPortscan(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string host, int port, Option<string> protocol);

        /// <summary>
        /// 扫描远程主机的指定端口 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
        /// </summary>
        /// <param name="host">需要扫描的目标主机，可以是域名或IP地址。</param>
        /// <param name="port">需要扫描的端口号，范围是 1 到 65535。</param>
        /// <param name="protocol">扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPortscanApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkPortscanApiResponse?> GetNetworkPortscanOrDefaultAsync(string host, int port, Option<string> protocol = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkPortscanAsync(host, port, protocol, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 扫描远程主机的指定端口 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="host">需要扫描的目标主机，可以是域名或IP地址。</param>
        /// <param name="port">需要扫描的端口号，范围是 1 到 65535。</param>
        /// <param name="protocol">扫描使用的协议，可以是 &#39;tcp&#39; 或 &#39;udp&#39;。 (optional, default to tcp)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkPortscanApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkPortscanApiResponse> GetNetworkPortscanAsync(string host, int port, Option<string> protocol = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkPortscan(host, protocol);

                FormatGetNetworkPortscan(ref host, ref port, ref protocol);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/portscan"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/portscan");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["host"] = ClientUtils.ParameterToString(host);
                    parseQueryStringLocalVar["port"] = ClientUtils.ParameterToString(port);

                    if (protocol.IsSet)
                        parseQueryStringLocalVar["protocol"] = ClientUtils.ParameterToString(protocol.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkPortscanApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkPortscanApiResponse>();
                        GetNetworkPortscanApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/portscan", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkPortscanDefaultImplementation(apiResponseLocalVar, host, port, protocol);

                        Events.ExecuteOnGetNetworkPortscan(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkPortscanDefaultImplementation(e, "/network/portscan", uriBuilderLocalVar.Path, host, port, protocol);
                Events.ExecuteOnErrorGetNetworkPortscan(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkPortscanApiResponse"/>
        /// </summary>
        public partial class GetNetworkPortscanApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkPortscanApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkPortscanApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkPortscanApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkPortscanApiResponse(ILogger<GetNetworkPortscanApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkPortscanApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkPortscanApiResponse(ILogger<GetNetworkPortscanApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPortscan200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPortscan200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPortscan200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPortscan400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPortscan400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPortscan400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkPortscan500Response? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkPortscan500Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkPortscan500Response? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkUrlstatus(ref string url);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        private void ValidateGetNetworkUrlstatus(string url)
        {
            if (url == null)
                throw new ArgumentNullException(nameof(url));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        private void AfterGetNetworkUrlstatusDefaultImplementation(IGetNetworkUrlstatusApiResponse apiResponseLocalVar, string url)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkUrlstatus(ref suppressDefaultLog, apiResponseLocalVar, url);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="url"></param>
        partial void AfterGetNetworkUrlstatus(ref bool suppressDefaultLog, IGetNetworkUrlstatusApiResponse apiResponseLocalVar, string url);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        private void OnErrorGetNetworkUrlstatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkUrlstatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, url);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="url"></param>
        partial void OnErrorGetNetworkUrlstatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string url);

        /// <summary>
        /// 检查URL的可访问性状态 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
        /// </summary>
        /// <param name="url">你需要检查其可访问性状态的完整URL。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkUrlstatusApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkUrlstatusApiResponse?> GetNetworkUrlstatusOrDefaultAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkUrlstatusAsync(url, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 检查URL的可访问性状态 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  &gt; [!TIP] &gt; **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 &#x60;HEAD&#x60; 请求，而不是 &#x60;GET&#x60; 请求。&#x60;HEAD&#x60; 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="url">你需要检查其可访问性状态的完整URL。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkUrlstatusApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkUrlstatusApiResponse> GetNetworkUrlstatusAsync(string url, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkUrlstatus(url);

                FormatGetNetworkUrlstatus(ref url);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/urlstatus"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/urlstatus");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkUrlstatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkUrlstatusApiResponse>();
                        GetNetworkUrlstatusApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/urlstatus", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkUrlstatusDefaultImplementation(apiResponseLocalVar, url);

                        Events.ExecuteOnGetNetworkUrlstatus(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkUrlstatusDefaultImplementation(e, "/network/urlstatus", uriBuilderLocalVar.Path, url);
                Events.ExecuteOnErrorGetNetworkUrlstatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkUrlstatusApiResponse"/>
        /// </summary>
        public partial class GetNetworkUrlstatusApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkUrlstatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkUrlstatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkUrlstatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkUrlstatusApiResponse(ILogger<GetNetworkUrlstatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkUrlstatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkUrlstatusApiResponse(ILogger<GetNetworkUrlstatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkUrlstatus200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkUrlstatus200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkUrlstatus200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetImageTobase64400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetImageTobase64400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetImageTobase64400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 502 BadGateway
            /// </summary>
            /// <returns></returns>
            public bool IsBadGateway => 502 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 502 BadGateway
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkUrlstatus502Response? BadGateway()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadGateway
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkUrlstatus502Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 502 BadGateway and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadGateway([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkUrlstatus502Response? result)
            {
                result = null;

                try
                {
                    result = BadGateway();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)502);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkWhois(ref string domain, ref Option<string> format);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="domain"></param>
        /// <param name="format"></param>
        /// <returns></returns>
        private void ValidateGetNetworkWhois(string domain, Option<string> format)
        {
            if (domain == null)
                throw new ArgumentNullException(nameof(domain));

            if (format.IsSet && format.Value == null)
                throw new ArgumentNullException(nameof(format));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="format"></param>
        private void AfterGetNetworkWhoisDefaultImplementation(IGetNetworkWhoisApiResponse apiResponseLocalVar, string domain, Option<string> format)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkWhois(ref suppressDefaultLog, apiResponseLocalVar, domain, format);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="format"></param>
        partial void AfterGetNetworkWhois(ref bool suppressDefaultLog, IGetNetworkWhoisApiResponse apiResponseLocalVar, string domain, Option<string> format);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="format"></param>
        private void OnErrorGetNetworkWhoisDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain, Option<string> format)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkWhois(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, domain, format);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        /// <param name="format"></param>
        partial void OnErrorGetNetworkWhois(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain, Option<string> format);

        /// <summary>
        /// 查询域名的WHOIS注册信息 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
        /// </summary>
        /// <param name="domain">你需要查询WHOIS信息的域名。</param>
        /// <param name="format">返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWhoisApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkWhoisApiResponse?> GetNetworkWhoisOrDefaultAsync(string domain, Option<string> format = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkWhoisAsync(domain, format, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 查询域名的WHOIS注册信息 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：&#x60;GET /api/v1/network/whois?domain&#x3D;google.com&amp;format&#x3D;json&#x60;   - 返回一个JSON对象，&#x60;whois&#x60; 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">你需要查询WHOIS信息的域名。</param>
        /// <param name="format">返回格式。留空或为 &#39;text&#39; 时返回原始WHOIS文本，设为 &#39;json&#39; 时返回结构化JSON。 (optional, default to text)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWhoisApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkWhoisApiResponse> GetNetworkWhoisAsync(string domain, Option<string> format = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkWhois(domain, format);

                FormatGetNetworkWhois(ref domain, ref format);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/whois"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/whois");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["domain"] = ClientUtils.ParameterToString(domain);

                    if (format.IsSet)
                        parseQueryStringLocalVar["format"] = ClientUtils.ParameterToString(format.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkWhoisApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkWhoisApiResponse>();
                        GetNetworkWhoisApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/whois", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkWhoisDefaultImplementation(apiResponseLocalVar, domain, format);

                        Events.ExecuteOnGetNetworkWhois(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkWhoisDefaultImplementation(e, "/network/whois", uriBuilderLocalVar.Path, domain, format);
                Events.ExecuteOnErrorGetNetworkWhois(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkWhoisApiResponse"/>
        /// </summary>
        public partial class GetNetworkWhoisApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkWhoisApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkWhoisApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkWhoisApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkWhoisApiResponse(ILogger<GetNetworkWhoisApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkWhoisApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkWhoisApiResponse(ILogger<GetNetworkWhoisApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkWhois200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkWhois200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkWhois200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkDns400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkDns400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkDns400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkWhois404Response? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkWhois404Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkWhois404Response? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkWxdomain(ref string domain);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="domain"></param>
        /// <returns></returns>
        private void ValidateGetNetworkWxdomain(string domain)
        {
            if (domain == null)
                throw new ArgumentNullException(nameof(domain));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        private void AfterGetNetworkWxdomainDefaultImplementation(IGetNetworkWxdomainApiResponse apiResponseLocalVar, string domain)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkWxdomain(ref suppressDefaultLog, apiResponseLocalVar, domain);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="domain"></param>
        partial void AfterGetNetworkWxdomain(ref bool suppressDefaultLog, IGetNetworkWxdomainApiResponse apiResponseLocalVar, string domain);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        private void OnErrorGetNetworkWxdomainDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkWxdomain(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, domain);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="domain"></param>
        partial void OnErrorGetNetworkWxdomain(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string domain);

        /// <summary>
        /// 检查域名在微信中的访问状态 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
        /// </summary>
        /// <param name="domain">需要查询的域名。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWxdomainApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkWxdomainApiResponse?> GetNetworkWxdomainOrDefaultAsync(string domain, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkWxdomainAsync(domain, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 检查域名在微信中的访问状态 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">需要查询的域名。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkWxdomainApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkWxdomainApiResponse> GetNetworkWxdomainAsync(string domain, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkWxdomain(domain);

                FormatGetNetworkWxdomain(ref domain);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/network/wxdomain"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/network/wxdomain");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["domain"] = ClientUtils.ParameterToString(domain);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkWxdomainApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkWxdomainApiResponse>();
                        GetNetworkWxdomainApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/network/wxdomain", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkWxdomainDefaultImplementation(apiResponseLocalVar, domain);

                        Events.ExecuteOnGetNetworkWxdomain(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkWxdomainDefaultImplementation(e, "/network/wxdomain", uriBuilderLocalVar.Path, domain);
                Events.ExecuteOnErrorGetNetworkWxdomain(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkWxdomainApiResponse"/>
        /// </summary>
        public partial class GetNetworkWxdomainApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetNetworkWxdomainApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkWxdomainApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkWxdomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkWxdomainApiResponse(ILogger<GetNetworkWxdomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkWxdomainApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkWxdomainApiResponse(ILogger<GetNetworkWxdomainApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkWxdomain200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkWxdomain200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkWxdomain200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkDns400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkDns400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkDns400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 502 BadGateway
            /// </summary>
            /// <returns></returns>
            public bool IsBadGateway => 502 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 502 BadGateway
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetNetworkWxdomain502Response? BadGateway()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadGateway
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetNetworkWxdomain502Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 502 BadGateway and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadGateway([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetNetworkWxdomain502Response? result)
            {
                result = null;

                try
                {
                    result = BadGateway();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)502);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
