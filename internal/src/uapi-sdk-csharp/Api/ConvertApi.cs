// <auto-generated>
/*
 * UAPI
 *
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using uapi-sdk-csharp.Client;
using uapi-sdk-csharp.Model;
using System.Diagnostics.CodeAnalysis;

namespace uapi-sdk-csharp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IConvertApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ConvertApiEvents Events { get; }

        /// <summary>
        /// Unix时间戳与日期字符串双向转换
        /// </summary>
        /// <remarks>
        /// 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 &#x60;1672531200&#x60;）和13位毫秒级（如 &#x60;1672531200000&#x60;）。 - **输入日期字符串**：为了确保准确性，推荐使用 &#x60;YYYY-MM-DD HH:mm:ss&#x60; 标准格式（如 &#x60;2023-01-01 08:00:00&#x60;）。  &gt; [!TIP] &gt; 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 &#x60;time&#x60; 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="time">一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 &#39;2023-10-27 10:30:00&#39;），系统将自动识别并转换。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConvertUnixtimeApiResponse"/>&gt;</returns>
        Task<IGetConvertUnixtimeApiResponse> GetConvertUnixtimeAsync(string time, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unix时间戳与日期字符串双向转换
        /// </summary>
        /// <remarks>
        /// 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 &#x60;1672531200&#x60;）和13位毫秒级（如 &#x60;1672531200000&#x60;）。 - **输入日期字符串**：为了确保准确性，推荐使用 &#x60;YYYY-MM-DD HH:mm:ss&#x60; 标准格式（如 &#x60;2023-01-01 08:00:00&#x60;）。  &gt; [!TIP] &gt; 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 &#x60;time&#x60; 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
        /// </remarks>
        /// <param name="time">一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 &#39;2023-10-27 10:30:00&#39;），系统将自动识别并转换。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConvertUnixtimeApiResponse"/>?&gt;</returns>
        Task<IGetConvertUnixtimeApiResponse?> GetConvertUnixtimeOrDefaultAsync(string time, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 美化并格式化JSON字符串
        /// </summary>
        /// <remarks>
        /// 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 &gt; [!NOTE] &gt; **请求格式** &gt; 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 &#x60;content&#x60; 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 &#x60;content&#x60; 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postConvertJsonRequest">这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostConvertJsonApiResponse"/>&gt;</returns>
        Task<IPostConvertJsonApiResponse> PostConvertJsonAsync(PostConvertJsonRequest postConvertJsonRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 美化并格式化JSON字符串
        /// </summary>
        /// <remarks>
        /// 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 &gt; [!NOTE] &gt; **请求格式** &gt; 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 &#x60;content&#x60; 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 &#x60;content&#x60; 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
        /// </remarks>
        /// <param name="postConvertJsonRequest">这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostConvertJsonApiResponse"/>?&gt;</returns>
        Task<IPostConvertJsonApiResponse?> PostConvertJsonOrDefaultAsync(PostConvertJsonRequest postConvertJsonRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetConvertUnixtimeApiResponse"/>
    /// </summary>
    public interface IGetConvertUnixtimeApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.GetConvertUnixtime200Response?>, IBadRequest<uapi-sdk-csharp.Model.GetConvertUnixtime400Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IPostConvertJsonApiResponse"/>
    /// </summary>
    public interface IPostConvertJsonApiResponse : uapi-sdk-csharp.Client.IApiResponse, IOk<uapi-sdk-csharp.Model.PostConvertJson200Response?>, IBadRequest<uapi-sdk-csharp.Model.PostConvertJson400Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ConvertApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetConvertUnixtime;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetConvertUnixtime;

        internal void ExecuteOnGetConvertUnixtime(ConvertApi.GetConvertUnixtimeApiResponse apiResponse)
        {
            OnGetConvertUnixtime?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetConvertUnixtime(Exception exception)
        {
            OnErrorGetConvertUnixtime?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostConvertJson;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostConvertJson;

        internal void ExecuteOnPostConvertJson(ConvertApi.PostConvertJsonApiResponse apiResponse)
        {
            OnPostConvertJson?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostConvertJson(Exception exception)
        {
            OnErrorPostConvertJson?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ConvertApi : IConvertApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ConvertApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ConvertApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConvertApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ConvertApi(ILogger<ConvertApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ConvertApiEvents convertApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ConvertApi>();
            HttpClient = httpClient;
            Events = convertApiEvents;
        }

        partial void FormatGetConvertUnixtime(ref string time);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="time"></param>
        /// <returns></returns>
        private void ValidateGetConvertUnixtime(string time)
        {
            if (time == null)
                throw new ArgumentNullException(nameof(time));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="time"></param>
        private void AfterGetConvertUnixtimeDefaultImplementation(IGetConvertUnixtimeApiResponse apiResponseLocalVar, string time)
        {
            bool suppressDefaultLog = false;
            AfterGetConvertUnixtime(ref suppressDefaultLog, apiResponseLocalVar, time);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="time"></param>
        partial void AfterGetConvertUnixtime(ref bool suppressDefaultLog, IGetConvertUnixtimeApiResponse apiResponseLocalVar, string time);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="time"></param>
        private void OnErrorGetConvertUnixtimeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string time)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetConvertUnixtime(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, time);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="time"></param>
        partial void OnErrorGetConvertUnixtime(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string time);

        /// <summary>
        /// Unix时间戳与日期字符串双向转换 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 &#x60;1672531200&#x60;）和13位毫秒级（如 &#x60;1672531200000&#x60;）。 - **输入日期字符串**：为了确保准确性，推荐使用 &#x60;YYYY-MM-DD HH:mm:ss&#x60; 标准格式（如 &#x60;2023-01-01 08:00:00&#x60;）。  &gt; [!TIP] &gt; 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 &#x60;time&#x60; 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
        /// </summary>
        /// <param name="time">一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 &#39;2023-10-27 10:30:00&#39;），系统将自动识别并转换。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConvertUnixtimeApiResponse"/>&gt;</returns>
        public async Task<IGetConvertUnixtimeApiResponse?> GetConvertUnixtimeOrDefaultAsync(string time, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetConvertUnixtimeAsync(time, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Unix时间戳与日期字符串双向转换 时间戳和日期字符串，哪个用着更顺手？别纠结了，这个接口让你轻松拥有两种格式！  ## 功能概述 这是一个非常智能的转换器。你给它一个 Unix 时间戳，它还你一个人类可读的日期时间；你给它一个日期时间字符串，它还你一个 Unix 时间戳。它会自动识别你输入的是哪种格式。  ## 使用须知 这个接口非常智能，能够自动识别输入格式：  - **输入时间戳**：支持10位秒级（如 &#x60;1672531200&#x60;）和13位毫秒级（如 &#x60;1672531200000&#x60;）。 - **输入日期字符串**：为了确保准确性，推荐使用 &#x60;YYYY-MM-DD HH:mm:ss&#x60; 标准格式（如 &#x60;2023-01-01 08:00:00&#x60;）。  &gt; [!TIP] &gt; 无论你输入哪种格式，响应中都会同时包含标准日期字符串和秒级Unix时间戳，方便你按需取用。  ## 错误处理指南 - **400 Bad Request**: 如果你提供的 &#x60;time&#x60; 参数既不是有效的时间戳，也不是我们支持的日期格式，就会收到这个错误。请检查你的输入值。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="time">一个智能时间参数，可传入Unix时间戳（10位或13位）或标准日期字符串（如 &#39;2023-10-27 10:30:00&#39;），系统将自动识别并转换。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConvertUnixtimeApiResponse"/>&gt;</returns>
        public async Task<IGetConvertUnixtimeApiResponse> GetConvertUnixtimeAsync(string time, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetConvertUnixtime(time);

                FormatGetConvertUnixtime(ref time);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/convert/unixtime"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/convert/unixtime");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["time"] = ClientUtils.ParameterToString(time);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetConvertUnixtimeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetConvertUnixtimeApiResponse>();
                        GetConvertUnixtimeApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/convert/unixtime", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetConvertUnixtimeDefaultImplementation(apiResponseLocalVar, time);

                        Events.ExecuteOnGetConvertUnixtime(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetConvertUnixtimeDefaultImplementation(e, "/convert/unixtime", uriBuilderLocalVar.Path, time);
                Events.ExecuteOnErrorGetConvertUnixtime(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetConvertUnixtimeApiResponse"/>
        /// </summary>
        public partial class GetConvertUnixtimeApiResponse : uapi-sdk-csharp.Client.ApiResponse, IGetConvertUnixtimeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetConvertUnixtimeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetConvertUnixtimeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetConvertUnixtimeApiResponse(ILogger<GetConvertUnixtimeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetConvertUnixtimeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetConvertUnixtimeApiResponse(ILogger<GetConvertUnixtimeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetConvertUnixtime200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetConvertUnixtime200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetConvertUnixtime200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.GetConvertUnixtime400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.GetConvertUnixtime400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.GetConvertUnixtime400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostConvertJson(PostConvertJsonRequest postConvertJsonRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postConvertJsonRequest"></param>
        /// <returns></returns>
        private void ValidatePostConvertJson(PostConvertJsonRequest postConvertJsonRequest)
        {
            if (postConvertJsonRequest == null)
                throw new ArgumentNullException(nameof(postConvertJsonRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postConvertJsonRequest"></param>
        private void AfterPostConvertJsonDefaultImplementation(IPostConvertJsonApiResponse apiResponseLocalVar, PostConvertJsonRequest postConvertJsonRequest)
        {
            bool suppressDefaultLog = false;
            AfterPostConvertJson(ref suppressDefaultLog, apiResponseLocalVar, postConvertJsonRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postConvertJsonRequest"></param>
        partial void AfterPostConvertJson(ref bool suppressDefaultLog, IPostConvertJsonApiResponse apiResponseLocalVar, PostConvertJsonRequest postConvertJsonRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="postConvertJsonRequest"></param>
        private void OnErrorPostConvertJsonDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, PostConvertJsonRequest postConvertJsonRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPostConvertJson(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, postConvertJsonRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="postConvertJsonRequest"></param>
        partial void OnErrorPostConvertJson(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, PostConvertJsonRequest postConvertJsonRequest);

        /// <summary>
        /// 美化并格式化JSON字符串 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 &gt; [!NOTE] &gt; **请求格式** &gt; 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 &#x60;content&#x60; 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 &#x60;content&#x60; 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
        /// </summary>
        /// <param name="postConvertJsonRequest">这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostConvertJsonApiResponse"/>&gt;</returns>
        public async Task<IPostConvertJsonApiResponse?> PostConvertJsonOrDefaultAsync(PostConvertJsonRequest postConvertJsonRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostConvertJsonAsync(postConvertJsonRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 美化并格式化JSON字符串 还在为一团乱麻的 JSON 字符串头疼吗？这个接口能瞬间让它变得井井有条，赏心悦目。  ## 功能概述 你只需要提供一个原始的、可能是压缩过的或者格式混乱的 JSON 字符串，这个 API 就会返回一个经过美化（带标准缩进和换行）的版本。这在调试 API 响应、或者需要在前端界面清晰展示 JSON 数据时非常有用。  ## 使用须知 &gt; [!NOTE] &gt; **请求格式** &gt; 请注意，待格式化的 JSON 字符串需要被包裹在另一个 JSON 对象中，作为 &#x60;content&#x60; 字段的值提交。具体格式请参考请求体示例。  ## 错误处理指南 - **400 Bad Request**: 最常见的原因是你提供的 &#x60;content&#x60; 字符串本身不是一个有效的 JSON。请仔细检查括号、引号是否正确闭合，或者有没有多余的逗号等语法错误。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postConvertJsonRequest">这是一个JSON对象，里面必须包含一个名为 &#x60;content&#x60; 的字段。这个字段的值，就是你希望格式化的、原始的JSON字符串。</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostConvertJsonApiResponse"/>&gt;</returns>
        public async Task<IPostConvertJsonApiResponse> PostConvertJsonAsync(PostConvertJsonRequest postConvertJsonRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostConvertJson(postConvertJsonRequest);

                FormatPostConvertJson(postConvertJsonRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/convert/json"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/convert/json");

                    httpRequestMessageLocalVar.Content = (postConvertJsonRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postConvertJsonRequest, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PostConvertJsonApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostConvertJsonApiResponse>();
                        PostConvertJsonApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/convert/json", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPostConvertJsonDefaultImplementation(apiResponseLocalVar, postConvertJsonRequest);

                        Events.ExecuteOnPostConvertJson(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostConvertJsonDefaultImplementation(e, "/convert/json", uriBuilderLocalVar.Path, postConvertJsonRequest);
                Events.ExecuteOnErrorPostConvertJson(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostConvertJsonApiResponse"/>
        /// </summary>
        public partial class PostConvertJsonApiResponse : uapi-sdk-csharp.Client.ApiResponse, IPostConvertJsonApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostConvertJsonApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostConvertJsonApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostConvertJsonApiResponse(ILogger<PostConvertJsonApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PostConvertJsonApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostConvertJsonApiResponse(ILogger<PostConvertJsonApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.PostConvertJson200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.PostConvertJson200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out uapi-sdk-csharp.Model.PostConvertJson200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public uapi-sdk-csharp.Model.PostConvertJson400Response? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<uapi-sdk-csharp.Model.PostConvertJson400Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out uapi-sdk-csharp.Model.PostConvertJson400Response? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
